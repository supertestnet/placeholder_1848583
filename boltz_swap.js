/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/@arkade-os/boltz-swap@0.2.6/dist/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{setArkPsbtField as e,ConditionWitness as t,CSVMultisigTapscript as a,buildOffchainTx as r,ArkAddress as s,VHTLC as i}from"https://cdn.jsdelivr.net/npm/@arkade-os/sdk@0.3.3/+esm";import{sha256 as n}from"https://cdn.jsdelivr.net/npm/@noble/hashes@2.0.0/sha2.js/+esm";import{hex as o,base64 as c}from"https://cdn.jsdelivr.net/npm/@scure/base@2.0.0/+esm";import{randomBytes as l}from"https://cdn.jsdelivr.net/npm/@noble/hashes@2.0.0/utils.js/+esm";import{Transaction as p}from"https://cdn.jsdelivr.net/npm/@scure/btc-signer@2.0.1/+esm";import{ripemd160 as d}from"https://cdn.jsdelivr.net/npm/@noble/hashes@2.0.0/legacy.js/+esm";import u from"https://cdn.jsdelivr.net/npm/light-bolt11-decoder@3.2.0/+esm";var w=class extends Error{isClaimable;isRefundable;pendingSwap;constructor(e={}){super(e.message??"Error during swap."),this.name="SwapError",this.isClaimable=e.isClaimable??!1,this.isRefundable=e.isRefundable??!1,this.pendingSwap=e.pendingSwap}},m=class extends w{constructor(e){super({message:"The invoice has expired.",...e}),this.name="InvoiceExpiredError"}},h=class extends w{constructor(e){super({message:"The provider failed to pay the invoice",...e}),this.name="InvoiceFailedToPayError"}},g=class extends w{constructor(e={}){super({message:"Not enough funds available",...e}),this.name="InsufficientFundsError"}},f=class extends Error{statusCode;errorData;constructor(e,t,a){super(e),this.name="NetworkError",this.statusCode=t,this.errorData=a}},v=class extends w{constructor(e={}){super({message:"Invalid API response",...e}),this.name="SchemaError"}},y=class extends w{constructor(e){super({message:"The swap has expired",...e}),this.name="SwapExpiredError"}},b=class extends w{constructor(e={}){super({message:"The transaction has failed.",...e}),this.name="TransactionFailedError"}},S=class extends w{constructor(e={}){super({message:"The transaction lockup has failed.",...e}),this.name="TransactionLockupFailedError"}},P=class extends w{constructor(e={}){super({message:"The transaction has been refunded.",...e}),this.name="TransactionRefundedError"}},k=e=>["invoice.failedToPay","transaction.claimed","swap.expired"].includes(e),T=e=>["transaction.refunded","transaction.failed","invoice.settled","swap.expired"].includes(e),R=e=>["transaction.mempool","transaction.confirmed"].includes(e),B=e=>"reverse"===e.type,x=e=>"submarine"===e.type,C=e=>["invoice.failedToPay","transaction.lockupFailed","swap.expired"].includes(e),A=e=>C(e.status)&&x(e)&&!1!==e.refundable,K=e=>e&&"object"==typeof e&&e.ARK&&"object"==typeof e.ARK&&e.ARK.BTC&&"object"==typeof e.ARK.BTC&&"string"==typeof e.ARK.BTC.hash&&"number"==typeof e.ARK.BTC.rate&&e.ARK.BTC.limits&&"object"==typeof e.ARK.BTC.limits&&"number"==typeof e.ARK.BTC.limits.maximal&&"number"==typeof e.ARK.BTC.limits.minimal&&"number"==typeof e.ARK.BTC.limits.maximalZeroConf&&e.ARK.BTC.fees&&"object"==typeof e.ARK.BTC.fees&&"number"==typeof e.ARK.BTC.fees.percentage&&"number"==typeof e.ARK.BTC.fees.minerFees,E={mutinynet:"https://api.boltz.mutinynet.arkade.sh",regtest:"http://localhost:9069"},F=class{wsUrl;apiUrl;network;constructor(e){this.network=e.network;const t=e.apiUrl||E[e.network];if(!t)throw new Error(`API URL is required for network: ${e.network}`);this.apiUrl=t,this.wsUrl=this.apiUrl.replace(/^http(s)?:\/\//,"ws$1://").replace("9069","9004")+"/v2/ws"}getApiUrl(){return this.apiUrl}getWsUrl(){return this.wsUrl}getNetwork(){return this.network}async getFees(){const[e,t]=await Promise.all([this.request("/v2/swap/submarine","GET"),this.request("/v2/swap/reverse","GET")]);if(!K(e))throw new v({message:"error fetching submarine fees"});if(!((a=t)&&"object"==typeof a&&a.BTC&&"object"==typeof a.BTC&&a.BTC.ARK&&"object"==typeof a.BTC.ARK&&a.BTC.ARK.hash&&"string"==typeof a.BTC.ARK.hash&&"number"==typeof a.BTC.ARK.rate&&a.BTC.ARK.limits&&"object"==typeof a.BTC.ARK.limits&&"number"==typeof a.BTC.ARK.limits.maximal&&"number"==typeof a.BTC.ARK.limits.minimal&&a.BTC.ARK.fees&&"object"==typeof a.BTC.ARK.fees&&"number"==typeof a.BTC.ARK.fees.percentage&&"object"==typeof a.BTC.ARK.fees.minerFees&&"number"==typeof a.BTC.ARK.fees.minerFees.claim&&"number"==typeof a.BTC.ARK.fees.minerFees.lockup))throw new v({message:"error fetching reverse fees"});var a;return{submarine:{percentage:e.ARK.BTC.fees.percentage,minerFees:e.ARK.BTC.fees.minerFees},reverse:{percentage:t.BTC.ARK.fees.percentage,minerFees:t.BTC.ARK.fees.minerFees}}}async getLimits(){const e=await this.request("/v2/swap/submarine","GET");if(!K(e))throw new v({message:"error fetching limits"});return{min:e.ARK.BTC.limits.minimal,max:e.ARK.BTC.limits.maximal}}async getReverseSwapTxId(e){const t=await this.request(`/v2/swap/reverse/${e}/transaction`,"GET");if(!(a=t)||"object"!=typeof a||"string"!=typeof a.id||"number"!=typeof a.timeoutBlockHeight)throw new v({message:`error fetching txid for swap: ${e}`});var a;return t}async getSwapStatus(e){const t=await this.request(`/v2/swap/${e}`,"GET");if(!(a=t)||"object"!=typeof a||"string"!=typeof a.status||void 0!==a.zeroConfRejected&&"boolean"!=typeof a.zeroConfRejected||void 0!==a.transaction&&(!a.transaction||"object"!=typeof a.transaction||"string"!=typeof a.transaction.id||void 0!==a.transaction.eta&&"number"!=typeof a.transaction.eta||void 0!==a.transaction.hex&&"string"!=typeof a.transaction.hex||void 0!==a.transaction.preimage&&"string"!=typeof a.transaction.preimage))throw new v({message:`error fetching status for swap: ${e}`});var a;return t}async getSwapPreimage(e){const t=await this.request(`/v2/swap/submarine/${e}/preimage`,"GET");if(!(a=t)||"object"!=typeof a||"string"!=typeof a.preimage)throw new v({message:`error fetching preimage for swap: ${e}`});var a;return t}async createSubmarineSwap({invoice:e,refundPublicKey:t}){if(66!=t.length)throw new w({message:"refundPublicKey must be a compressed public key"});const a=await this.request("/v2/swap/submarine","POST",{from:"ARK",to:"BTC",invoice:e,refundPublicKey:t});if(!(r=a)||"object"!=typeof r||"string"!=typeof r.id||"string"!=typeof r.address||"number"!=typeof r.expectedAmount||"string"!=typeof r.claimPublicKey||"boolean"!=typeof r.acceptZeroConf||!r.timeoutBlockHeights||"object"!=typeof r.timeoutBlockHeights||"number"!=typeof r.timeoutBlockHeights.unilateralClaim||"number"!=typeof r.timeoutBlockHeights.unilateralRefund||"number"!=typeof r.timeoutBlockHeights.unilateralRefundWithoutReceiver)throw new v({message:"Error creating submarine swap"});var r;return a}async createReverseSwap({invoiceAmount:e,claimPublicKey:t,preimageHash:a,description:r}){if(66!=t.length)throw new w({message:"claimPublicKey must be a compressed public key"});const s={from:"BTC",to:"ARK",invoiceAmount:e,claimPublicKey:t,preimageHash:a,...r?.trim()?{description:r.trim()}:{}},i=await this.request("/v2/swap/reverse","POST",s);if(!(n=i)||"object"!=typeof n||"string"!=typeof n.id||"string"!=typeof n.invoice||"number"!=typeof n.onchainAmount||"string"!=typeof n.lockupAddress||"string"!=typeof n.refundPublicKey||!n.timeoutBlockHeights||"object"!=typeof n.timeoutBlockHeights||"number"!=typeof n.timeoutBlockHeights.refund||"number"!=typeof n.timeoutBlockHeights.unilateralClaim||"number"!=typeof n.timeoutBlockHeights.unilateralRefund||"number"!=typeof n.timeoutBlockHeights.unilateralRefundWithoutReceiver)throw new v({message:"Error creating reverse swap"});var n;return i}async monitorSwap(e,t){return new Promise(((a,r)=>{const s=new globalThis.WebSocket(this.wsUrl),i=setTimeout((()=>{s.close(),r(new f("WebSocket connection timeout"))}),3e4);s.onerror=e=>{clearTimeout(i),r(new f(`WebSocket error: ${e.message}`))},s.onopen=()=>{clearTimeout(i),s.send(JSON.stringify({op:"subscribe",channel:"swap.update",args:[e]}))},s.onclose=()=>{clearTimeout(i),a()},s.onmessage=async a=>{const i=JSON.parse(a.data);if("update"!==i.event||i.args[0].id!==e)return;i.args[0].error&&(s.close(),r(new w({message:i.args[0].error})));const n=i.args[0].status;switch(n){case"invoice.settled":case"transaction.claimed":case"transaction.refunded":case"invoice.expired":case"invoice.failedToPay":case"transaction.failed":case"transaction.lockupFailed":case"swap.expired":s.close(),t(n);break;case"invoice.paid":case"invoice.pending":case"invoice.set":case"swap.created":case"transaction.claim.pending":case"transaction.confirmed":case"transaction.mempool":t(n)}}}))}async request(e,t,a){const r=`${this.apiUrl}${e}`;try{const e=await globalThis.fetch(r,{method:t,headers:{"Content-Type":"application/json"},body:a?JSON.stringify(a):void 0});if(!e.ok){const t=await e.text();let a;try{a=JSON.parse(t)}catch{}const r=a?`Boltz API error: ${e.status}`:`Boltz API error: ${e.status} ${t}`;throw new f(r,e.status,a)}if("0"===e.headers.get("content-length"))throw new f("Empty response from Boltz API");return await e.json()}catch(e){if(e instanceof f)throw e;throw new f(`Request to ${r} failed: ${e.message}`)}}},H=e=>{const t=u.decode(e),a=Number(t.sections.find((e=>"amount"===e.name))?.value??"0");return{expiry:t.expiry??3600,amountSats:Math.floor(a/1e3),description:t.sections.find((e=>"description"===e.name))?.value??"",paymentHash:t.sections.find((e=>"payment_hash"===e.name))?.value??""}},I=e=>H(e).amountSats,j=e=>H(e).paymentHash;function $(e){const t=e.identity.signerSession;return"function"==typeof t?t():t}async function L(e,t,a){return e.identity.sign(t,a)}var q=class{wallet;arkProvider;swapProvider;indexerProvider;constructor(e){if(!e.wallet)throw new Error("Wallet is required.");if(!e.swapProvider)throw new Error("Swap provider is required.");this.wallet=e.wallet;const t=e.wallet.arkProvider??e.arkProvider;if(!t)throw new Error("Ark provider is required either in wallet or config.");this.arkProvider=t;const a=e.wallet.indexerProvider??e.indexerProvider;if(!a)throw new Error("Indexer provider is required either in wallet or config.");this.indexerProvider=a,this.swapProvider=e.swapProvider}async savePendingReverseSwap(e){await this.wallet.contractRepository.saveToContractCollection("reverseSwaps",e,"id")}async savePendingSubmarineSwap(e){await this.wallet.contractRepository.saveToContractCollection("submarineSwaps",e,"id")}async getPendingReverseSwapsFromStorage(){return await this.wallet.contractRepository.getContractCollection("reverseSwaps")}async getPendingSubmarineSwapsFromStorage(){return await this.wallet.contractRepository.getContractCollection("submarineSwaps")}async createLightningInvoice(e){return new Promise(((t,a)=>{this.createReverseSwap(e).then((e=>{const a=H(e.response.invoice);t({amount:e.response.onchainAmount,expiry:a.expiry,invoice:e.response.invoice,paymentHash:a.paymentHash,pendingSwap:e,preimage:e.preimage})})).catch(a)}))}async sendLightningPayment(e){const t=await this.createSubmarineSwap(e);await this.savePendingSubmarineSwap(t);const a=await this.wallet.sendBitcoin({address:t.response.address,amount:t.response.expectedAmount});try{const{preimage:e}=await this.waitForSwapSettlement(t);return{amount:t.response.expectedAmount,preimage:e,txid:a}}catch(e){if(e.isRefundable){await this.refundVHTLC(t);const e=await this.getSwapStatus(t.id);await this.savePendingSubmarineSwap({...t,status:e.status})}throw new b}}async createSubmarineSwap(e){const t=o.encode(await this.wallet.identity.compressedPublicKey());if(!t)throw new w({message:"Failed to get refund public key from wallet"});const a=e.invoice;if(!a)throw new w({message:"Invoice is required"});const r={invoice:a,refundPublicKey:t},s=await this.swapProvider.createSubmarineSwap(r),i={id:s.id,type:"submarine",createdAt:Math.floor(Date.now()/1e3),request:r,response:s,status:"invoice.set"};return await this.savePendingSubmarineSwap(i),i}async createReverseSwap(e){if(e.amount<=0)throw new w({message:"Amount must be greater than 0"});const t=o.encode(await this.wallet.identity.compressedPublicKey());if(!t)throw new w({message:"Failed to get claim public key from wallet"});const a=l(32),r=o.encode(n(a));if(!r)throw new w({message:"Failed to get preimage hash"});const s={invoiceAmount:e.amount,claimPublicKey:t,preimageHash:r,...e.description?.trim()?{description:e.description.trim()}:{}},i=await this.swapProvider.createReverseSwap(s),c={id:i.id,type:"reverse",createdAt:Math.floor(Date.now()/1e3),preimage:o.encode(a),request:s,response:i,status:"swap.created"};return await this.savePendingReverseSwap(c),c}async claimVHTLC(i){const l=o.decode(i.preimage),d=await this.arkProvider.getInfo(),u=await this.wallet.getAddress();let w=await this.wallet.identity.xOnlyPublicKey();if(33==w.length)w=w.slice(1);else if(32!==w.length)throw new Error(`Invalid receiver public key length: ${w.length}`);let m=o.decode(d.signerPubkey);if(33==m.length)m=m.slice(1);else if(32!==m.length)throw new Error(`Invalid server public key length: ${m.length}`);const{vhtlcScript:h,vhtlcAddress:g}=this.createVHTLCScript({network:d.network,preimageHash:n(l),receiverPubkey:o.encode(w),senderPubkey:i.response.refundPublicKey,serverPubkey:o.encode(m),timeoutBlockHeights:i.response.timeoutBlockHeights});if(!h)throw new Error("Failed to create VHTLC script for reverse swap");if(g!==i.response.lockupAddress)throw new Error("Boltz is trying to scam us");const f=await this.indexerProvider.getVtxos({scripts:[o.encode(h.pkScript)],spendableOnly:!0});if(0===f.vtxos.length)throw new Error("No spendable virtual coins found");const v=f.vtxos[0],y=async(a,r)=>{const s=a.clone();let i=await L(this.wallet,s,r);return i=p.fromPSBT(i.toPSBT(),{allowUnknown:!0}),e(i,0,t,[l]),i},b=($(this.wallet),o.decode(d.checkpointTapscript)),S=a.decode(b),{arkTx:P,checkpoints:k}=r([{...f.vtxos[0],tapLeafScript:h.claim(),tapTree:h.encode()}],[{amount:BigInt(v.value),script:s.decode(u).pkScript}],S),T=await y(P),{arkTxid:R,finalArkTx:B,signedCheckpointTxs:x}=await this.arkProvider.submitTx(c.encode(T.toPSBT()),k.map((e=>c.encode(e.toPSBT()))));if(!this.validFinalArkTx(B,m,h.leaves))throw new Error("Invalid final Ark transaction");const C=await Promise.all(x.map((async e=>{const t=p.fromPSBT(c.decode(e),{allowUnknown:!0}),a=await y(t,[0]);return c.encode(a.toPSBT())})));await this.arkProvider.finalizeTx(R,C);const A=await this.getSwapStatus(i.id);await this.savePendingReverseSwap({...i,status:A.status})}async refundVHTLC(e){const t=await this.arkProvider.getInfo(),i=await this.wallet.getAddress();if(!i)throw new Error("Failed to get ark address from wallet");let n=await this.wallet.identity.xOnlyPublicKey();if(33==n.length)n=n.slice(1);else if(32!==n.length)throw new Error(`Invalid receiver public key length: ${n.length}`);let l=o.decode(t.signerPubkey);if(33==l.length)l=l.slice(1);else if(32!==l.length)throw new Error(`Invalid server public key length: ${l.length}`);const{vhtlcScript:d,vhtlcAddress:u}=this.createVHTLCScript({network:t.network,preimageHash:o.decode(j(e.request.invoice)),receiverPubkey:e.response.claimPublicKey,senderPubkey:o.encode(await this.wallet.identity.xOnlyPublicKey()),serverPubkey:t.signerPubkey,timeoutBlockHeights:e.response.timeoutBlockHeights});if(!d)throw new Error("Failed to create VHTLC script for reverse swap");if(u!==e.response.address)throw new Error("Boltz is trying to scam us");const w=await this.indexerProvider.getVtxos({scripts:[o.encode(d.pkScript)],spendableOnly:!0});if(0===w.vtxos.length)throw new Error("No spendable virtual coins found");const m=async(e,t)=>{const a=e.clone();let r=await L(this.wallet,a,t);return p.fromPSBT(r.toPSBT(),{allowUnknown:!0})},h=($(this.wallet),o.decode(t.checkpointTapscript)),g=a.decode(h),{arkTx:f,checkpoints:v}=r([{...w.vtxos[0],tapLeafScript:d.refund(),tapTree:d.encode()}],[{amount:BigInt(w.vtxos[0].value),script:s.decode(i).pkScript}],g),y=await m(f),{arkTxid:b,finalArkTx:S,signedCheckpointTxs:P}=await this.arkProvider.submitTx(c.encode(y.toPSBT()),v.map((e=>c.encode(e.toPSBT()))));if(!this.validFinalArkTx(S,l,d.leaves))throw new Error("Invalid final Ark transaction");const k=await Promise.all(P.map((async e=>{const t=p.fromPSBT(c.decode(e),{allowUnknown:!0}),a=await m(t,[0]);return c.encode(a.toPSBT())})));await this.arkProvider.finalizeTx(b,k);const T=await this.getSwapStatus(e.id);await this.savePendingSubmarineSwap({...e,status:T.status})}async waitAndClaim(e){return new Promise(((t,a)=>{this.swapProvider.monitorSwap(e.id,(async r=>{switch(r){case"transaction.mempool":case"transaction.confirmed":await this.savePendingReverseSwap({...e,status:r}),this.claimVHTLC(e).catch(a);break;case"invoice.settled":{await this.savePendingReverseSwap({...e,status:r});const s=(await this.swapProvider.getReverseSwapTxId(e.id)).id;if(!s||""===s.trim()){a(new w({message:`Transaction ID not available for settled swap ${e.id}.`}));break}t({txid:s});break}case"invoice.expired":await this.savePendingReverseSwap({...e,status:r}),a(new m({isRefundable:!0,pendingSwap:e}));break;case"swap.expired":await this.savePendingReverseSwap({...e,status:r}),a(new y({isRefundable:!0,pendingSwap:e}));break;case"transaction.failed":await this.savePendingReverseSwap({...e,status:r}),a(new b);break;case"transaction.refunded":await this.savePendingReverseSwap({...e,status:r}),a(new P);break;default:await this.savePendingReverseSwap({...e,status:r})}}))}))}async waitForSwapSettlement(e){return new Promise(((t,a)=>{let r=!1;this.swapProvider.monitorSwap(e.id,(async s=>{if(!r)switch(s){case"swap.expired":r=!0,await this.savePendingSubmarineSwap({...e,refundable:!0,status:s}),a(new y({isRefundable:!0,pendingSwap:e}));break;case"invoice.failedToPay":r=!0,await this.savePendingSubmarineSwap({...e,refundable:!0,status:s}),a(new h({isRefundable:!0,pendingSwap:e}));break;case"transaction.lockupFailed":r=!0,await this.savePendingSubmarineSwap({...e,refundable:!0,status:s}),a(new S({isRefundable:!0,pendingSwap:e}));break;case"transaction.claimed":{r=!0;const{preimage:a}=await this.swapProvider.getSwapPreimage(e.id);await this.savePendingSubmarineSwap({...e,preimage:a,status:s}),t({preimage:a});break}default:await this.savePendingSubmarineSwap({...e,status:s})}})).catch((e=>{r||(r=!0,a(e))}))}))}validFinalArkTx=(e,t,a)=>{const r=p.fromPSBT(c.decode(e),{allowUnknown:!0});if(!r)return!1;const s=[];for(let e=0;e<r.inputsLength;e++)s.push(r.getInput(e));return s.every((e=>e.witnessUtxo))};createVHTLCScript({network:e,preimageHash:t,receiverPubkey:a,senderPubkey:r,serverPubkey:s,timeoutBlockHeights:n}){let c=o.decode(a);if(33==c.length)c=c.slice(1);else if(32!==c.length)throw new Error(`Invalid receiver public key length: ${c.length}`);let l=o.decode(r);if(33==l.length)l=l.slice(1);else if(32!==l.length)throw new Error(`Invalid sender public key length: ${l.length}`);let p=o.decode(s);if(33==p.length)p=p.slice(1);else if(32!==p.length)throw new Error(`Invalid server public key length: ${p.length}`);const u=e=>e<512?"blocks":"seconds",w=new i.Script({preimageHash:d(t),sender:l,receiver:c,server:p,refundLocktime:BigInt(n.refund),unilateralClaimDelay:{type:u(n.unilateralClaim),value:BigInt(n.unilateralClaim)},unilateralRefundDelay:{type:u(n.unilateralRefund),value:BigInt(n.unilateralRefund)},unilateralRefundWithoutReceiverDelay:{type:u(n.unilateralRefundWithoutReceiver),value:BigInt(n.unilateralRefundWithoutReceiver)}});if(!w)throw new Error("Failed to create VHTLC script");const m="bitcoin"===e?"ark":"tark",h=w.address(m,p).encode();return{vhtlcScript:w,vhtlcAddress:h}}async getFees(){return this.swapProvider.getFees()}async getLimits(){return this.swapProvider.getLimits()}async getSwapStatus(e){return this.swapProvider.getSwapStatus(e)}async getPendingSubmarineSwaps(){const e=await this.getPendingSubmarineSwapsFromStorage();return e?e.filter((e=>"invoice.set"===e.status)):[]}async getPendingReverseSwaps(){const e=await this.getPendingReverseSwapsFromStorage();return e?e.filter((e=>"swap.created"===e.status)):[]}async getSwapHistory(){return[...await this.getPendingReverseSwapsFromStorage()||[],...await this.getPendingSubmarineSwapsFromStorage()||[]].sort(((e,t)=>t.createdAt-e.createdAt))}async refreshSwapsStatus(){for(const e of await this.getPendingReverseSwapsFromStorage())T(e.status)||this.getSwapStatus(e.id).then((({status:t})=>{this.savePendingReverseSwap({...e,status:t})})).catch((t=>{console.error(`Failed to refresh swap status for ${e.id}:`,t)}));for(const e of await this.getPendingSubmarineSwapsFromStorage())k(e.status)||this.getSwapStatus(e.id).then((({status:t})=>{this.savePendingSubmarineSwap({...e,status:t})})).catch((t=>{console.error(`Failed to refresh swap status for ${e.id}:`,t)}))}};export{q as ArkadeLightning,F as BoltzSwapProvider,g as InsufficientFundsError,m as InvoiceExpiredError,h as InvoiceFailedToPayError,f as NetworkError,v as SchemaError,w as SwapError,y as SwapExpiredError,b as TransactionFailedError,H as decodeInvoice,j as getInvoicePaymentHash,I as getInvoiceSatoshis,B as isPendingReverseSwap,x as isPendingSubmarineSwap,R as isReverseClaimableStatus,T as isReverseFinalStatus,k as isSubmarineFinalStatus,C as isSubmarineRefundableStatus,A as isSubmarineSwapRefundable};export default null;
//# sourceMappingURL=/sm/5097f32d87c6e3c2c8bb04550b2beb7a823127e0e1e4cd3bdee4407ebbb58ad4.map